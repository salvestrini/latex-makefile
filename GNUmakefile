
# Copyright 2008 Samuel Colin

# This file is based off Chris Monson's Makefile:
# http://www.bouncingchairs.net/oss
# As such, parts derived directly from it are licenced under the 
# GPLv2 (http://www.gnu.org/copyleft/gpl.html)
# under the following terms, copied verbatim from the original Makefile
# 
# Parts I added are licenced GPLv2 as well. Things may evolve later on.

HEVEAFLAGS ?= -fixpoint
BARELATEX ?= pdflatex
BIBFLAGS ?= -min-crossrefs=1
#VERBOSE := y

#
# EXTERNAL PROGRAMS:
# = ESSENTIAL PROGRAMS =
# == Basic Shell Utilities ==
CAT		:= cat
CP		:= cp -f
DIFF		:= diff
ECHO		:= echo
EGREP		:= egrep
ENV		:= env
MV		:= mv -f
RM		:= rm -f
SED		:= sed
SORT		:= sort
TOUCH		:= touch
UNIQ		:= uniq
WHICH		:= which
XARGS		:= xargs
# == LaTeX (tetex-provided) ==
BIBTEX          := bibtex $(BIBFLAGS)
DVIPS		:= dvips
LATEX		:= $(BARELATEX) -recorder -interaction=nonstopmode $(TEXFLAGS)
KPSEWHICH	:= kpsewhich
PS2PDF_NORMAL	:= ps2pdf
PS2PDF_EMBED	:= ps2pdf13
HEVEA           := hevea $(HEVEAFLAGS)
MAKEINDEX       := makeindex -q
# Glosstex, also ?
# = OPTIONAL PROGRAMS =
# == Makefile Color Output ==
TPUT		:= tput
# == Beamer Enlarged Output ==
PSNUP		?= psnup
# == Viewing Stuff ==
VIEW_POSTSCRIPT	?= gv
VIEW_PDF	?= xpdf
VIEW_GRAPHICS	?= display

# Characters that are hard to specify in certain places
space		:= $(empty) $(empty)
colon		:= \:
comma		:= ,

# Useful shell definitions
sh_true		:= :
sh_false	:= ! :

# Turn command echoing back on with VERBOSE=1
ifndef VERBOSE
QUIET	:= @
endif

# Turn on shell debugging with SHELL_DEBUG=1
# (EVERYTHING is echoed, even $(shell ...) invocations)
ifdef SHELL_DEBUG
SHELL	+= -x
endif

# Get the name of this makefile (always right in 3.80, often right in 3.79)
# This is only really used for documentation, so it isn't too serious.
ifdef MAKEFILE_LIST
this_file	:= $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
else
this_file	:= $(wildcard GNUmakefile makefile Makefile)
endif

# Terminal color definitions
black	:= $(shell $(TPUT) setaf 0)
red	:= $(shell $(TPUT) setaf 1)
green	:= $(shell $(TPUT) setaf 2)
yellow	:= $(shell $(TPUT) setaf 3)
blue	:= $(shell $(TPUT) setaf 4)
magenta	:= $(shell $(TPUT) setaf 5)
cyan	:= $(shell $(TPUT) setaf 6)
white	:= $(shell $(TPUT) setaf 7)
bold	:= $(shell $(TPUT) bold)
uline	:= $(shell $(TPUT) smul)
reset	:= $(shell $(TPUT) sgr0)

#
# User-settable definitions
#
LATEX_COLOR_WARNING	?= magenta
LATEX_COLOR_ERROR	?= red
LATEX_COLOR_INFO	?= green

# Gets the real color from a simple textual definition like those above
# $(call get-color,ALL_CAPS_COLOR_NAME)
# e.g., $(call get-color,WARNING)
get-color	= $(subst $(space),,$(foreach c,$(LATEX_COLOR_$1),$($c)))

#
# STANDARD COLORS
#
C_WARNING	:= $(call get-color,WARNING)
C_ERROR		:= $(call get-color,ERROR)
C_INFO		:= $(call get-color,INFO)
C_RESET		:= $(reset)

#
# PRE-BUILD TESTS
#

# Check that clean targets are not combined with other targets (weird things
# happen, and it's not easy to fix them)
hascleangoals	:= $(if $(sort $(filter clean clean-%,$(MAKECMDGOALS))),1)
hasbuildgoals	:= $(if $(sort $(filter-out clean clean-%,$(MAKECMDGOALS))),1)
ifneq "$(hasbuildgoals)" ""
ifneq "$(hascleangoals)" ""
$(error $(C_ERROR)Clean and build targets specified together$(C_RESET)))
endif
endif

# Extensions generated by LaTeX invocation that can be removed when complete
rm_ext		:= log,aux,dvi,ps,pdf,blg,bbl,out,nav,snm,toc,lof,lot,pfg,fls,vrb
backup_patterns	:= *.bak

############################################################################

#
# Utility Functions and Definitions
#

#
# BSD SED NOTES
#
# BSD SED is not very nice compared to GNU sed, but it is the most
# commonly-invoked sed on Macs (being based on BSD), so we have to cater to
# it or require people to install GNU sed.  It seems like the GNU
# requirement isn't too bad since this makefile is really a GNU makefile,
# but apparently GNU sed is much less common than GNU make in general, so
# I'm supporting it here.
#
# Sad experience has taught me the following about BSD sed:
#
# 	* \+ is not understood to mean \{1,\}
# 	* \| is meaningless (does not branch)
# 	* \n cannot be used as a substitution character
# 	* ? does not mean \{0,1\}, but is literal
# 	* a\ works, but only reliably for a single line if subsequent lines
# 		have forward slashes in them (as is the case in postscript)
#
# For more info (on the Mac) you can consult
#
# man -M /usr/share/man re_format
#
# And look for the word "Obsolete" near the bottom.

# Test that a file exists
# $(call test-exists,file)
test-exists		= [ -e '$1' ]

# Copy file1 to file2 only if file2 doesn't exist or they are different
# $(call copy-if-different,sfile,dfile)
copy-if-different	= $(call test-different,$1,$2) && $(CP) '$1' '$2'
copy-if-exists		= $(call test-exists,$1) && $(CP) '$1' '$2'
move-if-different	= $(call test-different,$1,$2) && $(MV) '$1' '$2'
replace-if-different-and-remove	= \
	$(call test-different,$1,$2) && $(MV) '$1' '$2' || $(RM) '$1'

# Note that $(DIFF) returns success when the files are the SAME....
# $(call test-different,sfile,dfile)
test-different		= ! $(DIFF) -q '$1' '$2' &>/dev/null
test-exists-and-different	= \
	$(call test-exists,$2) && $(call test-different,$1,$2)

# Return value 1, or value 2 if value 1 is empty
# $(call get-default,<possibly empty arg>,<default value if empty>)
get-default	= $(if $1,$1,$2)

# Gives a reassuring message about the failure to find include files
# $(call include-message,<list of include files>)
define include-message
$(strip \
$(if $(filter-out $(wildcard $1),$1),\
	$(shell $(ECHO) \
	"$(C_INFO)NOTE: You may ignore warnings about the"\
	"following files:" >&2;\
	$(ECHO) >&2; \
	$(foreach s,$(filter-out $(wildcard $1),$1),$(ECHO) '     $s' >&2;)\
	$(ECHO) "$(C_RESET)" >&2)
))
endef

#
# Functions used in generating output
#

# Outputs all source dependencies to stdout.  The first argument is the file to
# be parsed, the second is a list of files that will show up as dependencies in
# the new .d file created here.
#
# NOTE: BSD sed does not understand \|, so we have to do something more
# clunky to extract suitable extensions.
#
# $(call get-inputs,<parsed file>,<target files>)
define get-inputs
$(SED) \
-e '/^INPUT/!d' \
-e 's!^INPUT \(\./\)\{0,1\}!$2: !' \
-e '/\.tex$$/p' \
-e '/\.cls$$/p' \
-e '/\.sty$$/p' \
-e 'd' \
$1 | $(SORT) | $(UNIQ)
endef

# $(call get-bbls,<stem>,<targets>)
define get-bbls
$(SED) -e '/^No file \(.*\.bbl\)\./!d' -e 's/No file \(.*\.bbl\)\./\1/g' $1.log | $(SORT) | $(UNIQ) | \
$(SED) -e 's/^/$2: /g'
endef


# $(call get-bbl-deps,<stem>,,<targets>,<out file>)
# We exploit the fact that a bbl appearing in the .fls is not "No file" in the .log, and vice-versa
define get-bbl-deps
bblstems1=`$(SED) -e '/^No file \(.*\.bbl\)\./!d' -e 's/No file \(.*\)\.bbl\./\1/g' $1.log | $(SORT) | $(UNIQ)`; \
bblstems2=`$(SED) -e '/^INPUT.*\.bbl$$/!d' -e 's!^INPUT \(\./\)\{0,1\}\(.*\)\.bbl$$!\2!' $1.fls | $(SORT) | $(UNIQ)`; \
bblstems="$$bblstems1 $$bblstems2"; \
if [ ! -f $3 ]; then touch $3; fi; \
for i in $$bblstems; \
do \
  echo $2: $$i.bbl >>$3; \
  $(SED) \
  -e '/^\\bibdata/!d' \
  -e 's/\\bibdata{\([^}]*\)}/\1,/' \
  -e 's/,\{2,\}/,/g' \
  -e 's/,/.bib /g' \
  -e 's/ \{1,\}$$//' \
  $$i.aux | $(XARGS) $(KPSEWHICH) - | \
  $(SED) -e "s/^/$$i.bbl: /" | \
  $(SORT) | $(UNIQ) >>$3; \
done
endef

# TODO: analyse the .fls too...
# $(call get-inds,<stem>,<targets>)
define get-inds
$(SED) -e '/^No file \(.*\.ind\)\./!d' -e 's/No file \(.*\.ind\)\./\1/g' $1.log | $(SORT) | $(UNIQ) | \
$(SED) -e 's/^/$2: /g'
endef

# Compute index and glossary dependencies
# $(call make-inds-deps,<stem>,<targets>,<out file>)
define make-inds-deps
indstems1=`$(SED) -e '/^No file \(.*\.ind\)\./!d' -e 's/No file \(.*\.ind\)\./\1/g' $1.log | $(SORT) | $(UNIQ)`; \
indstems2=`$(SED) -e '/^INPUT.*\.ind$$/!d' -e 's!^INPUT \(\./\)\{0,1\}\(.*\.ind\)$$!\2!' $1.fls | $(SORT) | $(UNIQ)`; \
glsstems1=`$(SED) -e '/^No file \(.*\.gls\)\./!d' -e 's/No file \(.*\.gls\)\./\1/g' $1.log | $(SORT) | $(UNIQ)`; \
glsstems2=`$(SED) -e '/^INPUT.*\.gls$$/!d' -e 's!^INPUT \(\./\)\{0,1\}\(.*\.gls\)$$!\2!' $1.fls | $(SORT) | $(UNIQ)`; \
indstems="$$indstems1 $$indstems2"; \
glsstems="$$glsstems1 $$glsstems2"; \
if [ ! -f $3 ]; then touch $3; fi; \
if [ "x$$indstems" != "x " ]; then echo $2: $$indstems >>$3; fi; \
if [ "x$$glsstems" != "x " ]; then echo $2: $$glsstems >>$3; fi
endef

# Outputs all bibliography files to stdout.  Arg 1 is the source stem, arg 2 is
# a list of targets for each dependency found.
#
# The script kills all lines that do not contain bibdata.  Remaining lines have
# the \bibdata macro and delimiters removed to create a dependency list.  A
# trailing comma is added, then all adjacent commas are collapsed into a single
# comma.  Then commas are replaced with the string .bib[space], and the
# trailing space is killed off.  This produces a list of space-delimited .bib
# filenames, which is what the make dep file expects to see.
#
# $(call get-bibs,<aux file>,<targets>)
define get-bibs
$(SED) \
-e '/^\\bibdata/!d' \
-e 's/\\bibdata{\([^}]*\)}/\1,/' \
-e 's/,\{2,\}/,/g' \
-e 's/,/.bib /g' \
-e 's/ \{1,\}$$//' \
$1 | $(XARGS) $(KPSEWHICH) - | \
$(SED) \
-e 's/^/$2: /' | \
\$(SORT) | $(UNIQ)
endef

# Makes a an aux file that only has stuff relevant to the dvi in it
# $(call make-auxdvi-file,<flattened-aux>,<new-aux>)
define make-auxdvi-file
$(SED) \
-e '/^\\newlabel/!d' \
$1 > $2
endef

# Makes an aux file that only has stuff relevant to the bbl in it
# $(call make-auxbbl-file,<flattened-aux>,<new-aux>)
define make-auxbbl-file
$(SED) \
-e '/^\\newlabel/d' \
$1 > $2
endef

# Colorizes real, honest-to-goodness LaTeX errors that can't be overcome with
# recompilation.
#
# $(call colorize-latex-errors,<log file>)
define colorize-latex-errors
$(SED) \
-e '/^! LaTeX Error: File/d' \
-e '/^! LaTeX Error: Cannot determine size/d' \
-e '/^! /,/^$$/{' \
-e '  H' \
-e '  /^$$/{' \
-e '    x' \
-e '    s/^.*$$/$(C_ERROR)&$(C_RESET)/' \
-e '    p' \
-e '  }' \
-e '}' \
-e 'd' \
$1
endef

# Get all important .aux files from the top-level .aux file and merges them all
# into a single file, which it outputs to stdout.
#
# $(call flatten-aux,<toplevel aux>,<output file>)
define flatten-aux
$(SED) \
-e '/\\@input{\(.*\)}/{' \
-e     's//\1/' \
-e     's![.:]!\\&!g' \
-e     'h' \
-e     's!.*!\\:\\\\@input{&}:{!' \
-e     'p' \
-e     'x' \
-e     's/.*/r &/p' \
-e     's/.*/d/p' \
-e     's/.*/}/p' \
-e     'd' \
-e '}' \
-e 'd' \
'$1' > "$1.$$$$.sed.make"; \
$(SED) -f "$1.$$$$.sed.make" '$1' > "$1.$$$$.make"; \
$(SED) \
-e '/^\\relax/d' \
-e '/^\\bibcite/d' \
-e 's/^\(\\newlabel{[^}]\{1,\}}\).*/\1/' \
"$1.$$$$.make" | $(SORT) > '$2'; \
$(RM) $1.$$$$.{sed.,}make
endef

# Generate pdf from postscript
ps2pdf_normal	:= $(PS2PDF_NORMAL)
ps2pdf_embedded	:= \
	$(PS2PDF_EMBED) \
	-dPDFSETTINGS=/printer \
	-dEmbedAllFonts=true \
	-dSubsetFonts=true \
	-dMaxSubsetPct=100

# Colorize LaTeX output.
color_tex	:= \
	$(SED) \
	-e '/^[[:space:]]*Output written/{' \
	-e ' s/.*(\([^)]\{1,\}\)).*/Success!  Wrote \1/' \
	-e ' s/[[:digit:]]\{1,\}/$(C_INFO)&$(C_RESET)/g' \
	-e ' s/Success!/$(C_INFO)&$(C_RESET)/g' \
	-e '}' \
	-e 's/^! *LaTeX Error:.*/$(C_ERROR)&$(C_RESET)/' -e 't' \
	-e 's/^LaTeX Warning:.*/$(C_WARNING)&$(C_RESET)/' -e 't' \
	-e 's/^Underfull.*/$(C_WARNING)&$(C_RESET)/' -e 't' \
	-e 's/^Overfull.*/$(C_WARNING)&$(C_RESET)/' -e 't' \
	$(if $(VERBOSE),,-e 'd')

# Colorize BibTeX output.
color_bib	:= \
	$(SED) \
	-e 's/^Warning--.*/$(C_WARNING)&$(C_RESET)/' -e 't' \
	-e '/---/,/^.[^:]/{' \
	-e '  H' \
	-e '  /^.[^:]/{' \
	-e '    x' \
	-e '    s/\n\(.*\)/$(C_ERROR)\1$(C_RESET)/' \
	-e '	p' \
	-e '    s/.*//' \
	-e '    h' \
	-e '    d' \
	-e '  }' \
	-e '  d' \
	-e '}' \
	-e '/(.*error.*)/s//$(C_ERROR)&$(C_RESET)/' \
	$(if $(VERBOSE),,-e 'd')


# $(call latex-color-log,<LaTeX stem>)
latex-color-log	= $(color_tex) $1.log

# Make beamer output big enough to print on a full page.  Landscape doesn't
# seem to work correctly.
enlarge_beamer	= $(PSNUP) -l -1 -W128mm -H96mm -pletter

# $(call test-run-again,<source stem>)
test-run-again	= $(EGREP) -q '^(.*Rerun .*|No file $1\.[^.]+\.)$$' $1.log

# This tests whether the dvi target should be run at all, from viewing the log
# file.
# $(call test-log-for-need-to-run,<source stem>)
define test-log-for-need-to-run
$(SED) \
-e '/^No file $(subst .,\\.,$1)\.aux\./d' \
$1.log \
| $(EGREP) -q '^(.*Rerun .*|No file $1\.[^.]+\.|LaTeX Warning: File.*)$$'
endef

# LaTeX invocations
#
# $(call latex,<tex file>)
run-latex	= $(LATEX) $1 > /dev/null

# BibTeX invocations
#
# $(call run-bibtex,<tex stem>)
run-bibtex	= $(BIBTEX) $1 | $(color_bib)


# Convert DVI to Postscript
# $(call make-ps,<dvi file>,<ps file>,<log file>,[<paper size>])
make-ps		= \
	$(DVIPS) -o '$2' $(if $(filter-out BEAMER,$4),-t$(firstword $4),) '$1' \
		$(if $(filter BEAMER,$4),| $(enlarge_beamer)) &> $3

# Convert Postscript to PDF
# $(call make-pdf,<ps file>,<pdf file>,<log file>,<embed file>)
make-pdf	= \
	$(if $(filter 1,$(shell $(CAT) '$4')),\
		$(ps2pdf_embedded),\
		$(ps2pdf_normal)) '$1' '$2' &> $3

# Display information about what is being done
# $(call echo-build,<output file>,[<run number>])
echo-build	= $(ECHO) "$(C_INFO)= $1 --> $2$(if $3, ($3),) =$(C_RESET)"
echo-dep	= $(ECHO) "$(C_INFO)= $1 --> $2 =$(C_RESET)"

# Display a list of something
# $(call echo-list,<values>)
echo-list	= for x in $1; do $(ECHO) "$$x"; done

############################################################################

